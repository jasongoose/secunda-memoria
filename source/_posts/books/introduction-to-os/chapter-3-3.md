---
title: 3-3. 프로세스의 연산
date: 2024-11-26 21:58:25
categories:
  - Books
  - 쉽게 배우는 운영체제
#tags:
---
## 프로세스의 구조

### 코드 영역

- 프로그램의 본문이 기술된 곳으로, "텍스트 영역"이라고도 불립니다.
- 해당 영역은 읽기만 가능합니다.

### 데이터 영역

- 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳입니다.
- 상수로 선언된 변수는 읽기만 가능하고 나머지 변수는 읽기와 쓰기가 가능합니다.

### 스택 영역

- 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳입니다.
  - 예) 프로세스 내에서 함수를 호출하고 나서 다시 돌아갈 위치
- 운영체제가 관리하는 영역이기에 사용자에게 숨겨져 있고 읽기, 쓰기가 불가합니다.

## 프로세스의 생성과 복사

- 프로그램을 실행하면 운영체제가 PCB가 생성하고 프로세스를 위한 메모리 영역을 확보하여 프로세스를 실행합니다.

### fork() 시스템 호출의 개념

- 실행 중인 프로세스를 복사하는 함수
- 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 부모-자식 관계가 됩니다.

### fork() 시스템 호출의 동작 과정

- fork 시스템 호출을 하면 PCB와 더불어 부모 프로세스 영역의 대부분이 복사되어 자식 프로세스를 생성합니다.
- 자식 프로세스는 부모 프로세스와 다른 영역에 위치하므로 메모리 정보가 다릅니다.
- 부모 프로세스의 CPID는 자식 프로세스의 PID, 자식 프로세스의 PPID는 부모 프로세스의 PID가 됩니다.
- 자식 프로세스의 CPID는 -1을 가집니다.

![fork() 시스템 호출](/images/fork_system_call.png)

### fork() 시스템 호출의 장점

#### 프로세스의 생성 속도가 빠르다.

- 저장장치로부터 프로그램을 새로 가져오지 않고 메모리 상에서 보다 빠르게 프로세스를 생성할 수 있습니다.

#### 추가 작업 없이 자원을 상속할 수 있다.

- 부모 프로세스가 사용하던 자원을 자식 프로세스에 바로 상속할 수 있습니다.
  - 예) 부모 프로세스가 특정 파일에 접근하기 위해 초기화했다면 자식 프로세스는 바로 해당 파일에 바로 접근할 수 있습니다.

#### 시스템 관리를 효율적으로 할 수 있다.

- 부모 프로세스와 자식 프로세스가 PPID, CPID로 연결되므로 자식 프로세스가 종료되고 나서 부모 프로세스가 자원을 회수할 수 있습니다.

### fork() 시스템 호출의 예

```c
#include <stdio.h>
#include <unistd.h>

void main()
{
    int pid;
    
    pid = fork(); // 복사된 자식 프로세스는 독립적으로 여기서부터 실행함

    // 부모 프로세스라면 양수, 자식 프로세스는 0을 가짐    
    if (pid < 0)
    {
        printf("Error");
        exit(-1);
    }
    
    else if (pid == 0)
    {
        printf("Child");
        exit(0);
    }

    else
    {
        printf("Parent");
        exit(0);
    }
}
```

## 프로세스의 전환

- 복사된 프로세스를 간단하게 새로운 프로세스로 바꿀 수 있습니다.

### exec() 시스템 호출의 개념

- 복사된 자식 프로세스의 구조를 재활용하여 다른 프로세스를 실행합니다.
- 이미 만들어진 프로세스의 PCB, 메모리 영역, 부모-자식 관계 등을 그대로 사용할 수 있습니다.

### exec() 시스템 호출의 동작 과정

- exec 시스템 호출을 하면 기존 프로세스의 코드 영역, 데이터 영역, 스택 영역이 새로운 프로세스에 맞춰서 변합니다.
- 단, 기존 PCB에 답긴 PID, PPID, CPID, 메모리 관련 정보 등은 유지되고 PC를 비롯한 각종 레지스터 중간값, 사용한 파일 정보가 모두 리셋됩니다.
  - 마지 프로세를 처음부터 시작하는 것처럼 프로세스의 내용이 바뀝니다.

![exec() 시스템 호출](/images/exec_system_call.png)

### exec() 시스템 호출의 예

```c
#include <stdio.h>
#include <unistd.h>

void main()
{
    int pid;
    
    pid = fork(); // 자식 프로세스 생성

    if (pid < 0)
    {
        printf("Error");
        exit(-1);
    }
    
    else if (pid == 0)
    {
        // 자식 프로세스 영역에서 mplayer 코드를 실행
        execlp("mplayer", "mplayer", NULL);
        exit(0);
    }

    else
    {
        // 부모 프로세스가 자식 프로세스가 종료될 때까지 대기
        // 자식 프로세스가 종료되면 자원을 회수하고 재개하는 지점
        wait(NULL);
        printf("mplayer Terminated");
        exit(0);
    }
}
```

## 프로세스의 계층 구조

- 프로세스의 복사, 상속으로 형성된 프로세스 간의 부모-자식 관계는 곧 계층구조를 형성합니다.

### 유닉스의 프로세스 계층 구조

- 유닉스에서 커널이 실행되어 생성된 프로세스들 중 init 프로세스는 전체 프로세스의 출발점이 됩니다.
- init 프로세스은 login, shell 등의 자식 프로세스를 가집니다.

![유닉스 프로세스 계층구조](/images/process_hierarchy.png)

### 프로세스 계층 구조의 장점

#### 여러 작업의 동시 처리

- 다수 사용자들을 처리하기 위해 init 프로세스에서 fork 시스템 호출로 자식 프로세스들을 생성하고 각각 exec 시스템 호출로 login 프로세스로 바꿉니다.
- 각 사용자가 로그인을 마치면 login 프로세스는 exec 시스템 호출로 shell 프로세스로 바꾼 뒤 사용자에게 인터페이스를 제공합니다.
  - 이는 login 프로세스와 PCB를 지우고 다시 shell 프로세스를 생성하는 것보다 훨씬 더 효율적입니다.

#### 용이한 자원 회수

- 프로세스간의 책임 관계가 분명해져서 임의의 프로세스가 종료되면 운영체제의 개입없이 부모 프로세스가 자원을 회수할 수 있습니다.

### 미아 프로세스

- 부모 프로세스가 먼저 종료되거나 비정상적으로 종료되어 메모리 상에 그대로 남아있는 프로세스
- 미아 프로세스가 많아지면 가용공간이 적어지면서 효율적인 자원운용에 어려움을 주므로, 운영체제는 주기적으로 자원회수를 수행해야 합니다.

#### exit 함수
- C언어에서 함수 마지막에 return 문 또는 exit 문을 작성하는 것은 자식 프로세스가 정상적으로 종료되었음을 부모 프로세스에 알려서 자원회수나 자식 프로세스 동기화를 수행하기 위한 목적을 가집니다.

```c
int main()
{
    printf("Hello \n");
    exit(0);
}
```